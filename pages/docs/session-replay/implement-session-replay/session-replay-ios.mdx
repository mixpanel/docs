import { Callout } from 'nextra/components'

# Implement Session Replay (iOS)

<Callout type="info">
The iOS Session Replay is in invite-only Beta access for customers on our Enterprise plan. Reach out to your Account Manager for any questions about Session Replay or the iOS Beta access.
</Callout>

<Callout type="warning">
Since our Beta program offers early access, some functionality, including data masking features, may contain bugs and cause crashes. We recommend thoroughly testing before enabling in production.

Our Session Replay Beta Service Addendum can be found [here](https://mixpanel.com/legal/session-replay-beta-service-addendum/).
</Callout>

## Overview

This developer guide will assist you in configuring your Swift app for [Session Replay](/docs/session-replay) using the [Session Replay SDK (Swift)](/docs/tracking-methods/sdks/swift-replay). Learn more about [viewing captured Replays in your project here](/docs/session-replay).

## Prerequisite

You are already a Mixpanel customer and have the latest version of the [Mixpanel Swift SDK](/docs/tracking-methods/sdks/swift) installed (minimum supported version is [v4.3.1](https://github.com/mixpanel/mixpanel-swift/releases/tag/v4.3.1)). If not, please follow [this doc](/docs/quickstart/install-mixpanel) to install the SDK.

## Installation

To capture Session Replays in your app, add the [Session Replay SDK]((/docs/tracking-methods/sdks/swift-replay)) using Swift Package Manager directly in Xcode:

1. In Xcode, go to File → **Add Package Dependencies…**
2. Paste the GitHub URL: `https://github.com/mixpanel/mixpanel-ios-session-replay-package`
3. Follow the prompts to select the latest version and add the package to your project.

### Initialize

You should have the main Mixpanel SDK installed (minimum version `v4.3.1`), if not, please refer to [Prerequisite](/docs/session-replay/session-replay-ios#prerequisite). 

Add the following initialization code at the start of your app's lifecycle in `SwiftUI` and `UIKit`:

**SwiftUI**

```swift Swift
import Mixpanel
import MixpanelSessionReplay
 
struct SessionReplayDemoApp: App {
    @State private var isActive = true
    @Environment(\\.scenePhase) private var scenePhase
 
    var body: some Scene {
        WindowGroup {
            ...
        }
        .onChange(of: scenePhase) {
            if scenePhase == .active {
                let config = MPSessionReplayConfig(wifiOnly: false, recordSessionsPercent: 100.0)
                let sessionReplayInstance = MPSessionReplay.initialize(token: Mixpanel.mainInstance().apiToken, distinctId: Mixpanel.mainInstance().distinctId, config: config)
 
                sessionReplayInstance.loggingEnabled = true
                sessionReplayInstance.startRecording()
            }
        }
}
```

**UIKit**

```swift Swift
import Foundation
import UIKit
 
import Mixpanel
import MixpanelSessionReplay
 
class AppDelegate: UIResponder, UIApplicationDelegate {
 
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
        Mixpanel.initialize(token: token, trackAutomaticEvents: true)
 
        let config = MPSessionReplayConfig(
            wifiOnly: false,
            recordSessionsPercent: 100.0
        )
        let sesionReplayInstance = MPSessionReplay.initialize(
            token: Mixpanel.mainInstance().apiToken,
            distinctId: Mixpanel.mainInstance().distinctId,
            config: config
        )
        #if DEBUG
        Mixpanel.mainInstance().loggingEnabled = true
        MPSessionReplay.getInstance()?.loggingEnabled = true
				#endif
        return true
    }
 
    func applicationDidBecomeActive(_ application: UIApplication) {
        MPSessionReplay.getInstance()?.startRecording()
    }
 
}
```
## Capturing Replays

<Callout type="warning">
	Test in a sandbox project and start with a smaller sample rate. This allows you to monitor performance, usage, and ensure your privacy rules align with your company policies.
</Callout>

You can capturing replay data using a sampling method (recommended), or customize when and where replays are captured manually using methods provided by the Session Replay Swift SDK.

### Sampling

We recommend using the sampling method unless you need to customize when you capture replay data.

To enable Session Replay and set your sampling rate, create a `SessionReplayConfig` object and set the `recordSessionsPercent` with a value between `0.0` and `100.0`. At `0.0` no sessions will be recorded, at `100.0` all sessions will be recorded.

Start with a low sampling rate, then adjust according to your specific analytics needs.

**Example Usage**

```swift Swift
// records 1% of all sessions
MPSessionReplayConfig(recordSessionsPercent: 1.0)
```

### Manual Capture

To programatically start and stop replay capture, use the `.startRecording()` and `.stopRecording()` methods. This is optional, and can be used primarily to programmatically start and stop recording, or exclude something specific from recording.

#### Start Capturing Replay Data

Call `.startRecording()` to force recording to begin, regardless of the `recordSessionsPercent` init option. The recording automatically stops when the app goes to the background. Therefore, if you want to continuously record the replays, you will need to restart the replay once the app becomes active again.

This will have no effect if replay data collection is already in progress.

**Example Usage**

```swift Swift
// manually trigger a replay capture
MPSessionReplay.getInstance()?.startRecording()
```

#### Stop Capturing Replay Data

Call `.stopRecording()` to stop any active replay data collection. The SDK automatically stops recording when the app goes to the background.

This will have no effect if there is no replay data collection in progress.

**Example Usage**

```swift Swift
// manually end a replay capture
MPSessionReplay.getInstance()?.stopRecording()
```

#### Example Scenarios

| Scenario | Guidance | 
| --- | --- |
| We have a sensitive screen we don't want to capture | When user is about to access the sensitive screen, call `.stopRecording()`. To resume recording once they leave this screen, you can resume recording with `.startRecording()`  | 
| We only want to record certain types of users (e.g. Free plan users only) | Using your application code, determine if current user meets the criteria of users you wish to capture. If they do, then call `.startRecording()` to force recording on |
| We only want to users utilizing certain features | When user is about to access the feature you wish to capture replays for, call `.startRecording()` to force recording on |

### Additional Configuration Options

Upon initialization you can provide a `SessionReplayConfig` object to customize your replay capture.

Currently, there are only five config options:

| Option | Description | Default | 
| --- | --- | --- |
| `wifiOnly` | When `true`, replay events will only be flushed to the server when the device has a WiFi connection. If there is no wifi, flushes are skipped and the events remain in the in-memory queue until wifi is restored (or until the queue reaches its limit and the oldest events are evicted to make room for newer events). <br/> When `false`, replay events will be flushed with any network connection, including cellular. | `true` |
| `recordSessionsPercent` | This is a value between `0.0` and `100.0` that controls the sampling rate for recording session replays. <br/> At `0.0` no sessions will be recorded. At `100.0` all sessions will be recorded.  | `0.0` |
| `autoMaskedViews` | This is a `Set` of enum options for the types of views that should be masked by the SDK automatically. | `Image`, `Text`, and `Web` |
| `autoCapture` | This an enum to selectively disable the runtime method replacement functionality (aka “swizzling") in the event that it conflicts with another SDK (like [New Relic](https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/#method)) | `.enabled` |

**autoMaskedViews Example Usage**
```swift Swift
// mask images only
MPSessionReplayConfig(recordSessionsPercent: 100.0, autoMaskedViews: [.Image])

// disable auto masking
MPSessionReplayConfig(recordSessionsPercent: 100.0, autoMaskedViews: [])

// mask image, text and WebViews
MPSessionReplayConfig(recordSessionsPercent: 100.0)
```

**autoCapture Example Usage**

```swift Swift
// auto capture on both view controller lifecycle methods and touch events
MPSessionReplayConfig(recordSessionsPerecent: 100.0, autoCapture: .enabled)

// auto capture only on view controller lifecycle events
MPSessionReplayConfig(recordSessionsPerecent: 100.0, autoCapture: .viewControllerLifecycle)

// auto capture only on touch events
MPSessionReplayConfig(recordSessionsPerecent: 100.0, autoCapture: .touch)

// disable auto capture
// use this if you want to keep all functionality in the conflicting SDK
MPSessionReplayConfig(recordSessionsPerecent: 100.0, autoCapture: .disabled)
```

#### Manual Screenshot Capture

If you have partially or completely disabled automatic screen capture via the `autoCapture` config setting above, you can manually capture screenshots by calling `.captureScreenshot()`:

**Example Usage**

```swift Swift
// manually capture screenshots
MPSessionReplay.getInstance()?.captureScreenshot()

// manually capture screenshots triggered by a touch event
MPSessionReplay.getInstance()?.captureScreenshot(withTouchEvent: touchEvent)
```

If you choose to disable auto capture and do manual screen capturing instead, it will be up to you to determine when, where and how you call the `.captureScreenshot()` method in your application. The most naïve approach would be to call it on a `Timer`.

**Example Usage**

```swift Swift
// trigger manual screenshot capture using Timer
let screenshotTimer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in
    MPSessionReplay.getInstance()?.captureScreenshot()
}
```

Keeping in mind that this is relatively inefficient and will result in capturing unnecessary/unchanged screenshots, it is also possible to miss important moments in between the timed screenshots. Taking scr

## Replay ID

When a replay capture begins, a Replay ID is generated by the SDK and is attached as an event property (`$mp_replay_id`) to events tracked by the SDK during the capture session. Events containing the same $mp_replay_id will appear in the same Replay.

If you are sending any events not coming from the SDK, add the `$mp_replay_id` event property to attribute the event to a specific Replay.

### Server-side Stitching

Server-Side Stitching allows you to easily watch Replays for events that were not fired from the SDK.

It works by inferring the Replay that an event belong using the Distinct ID and time property attached to the event. This is especially useful if you have events coming in from multiple sources.

For example, let's say a user with Distinct ID “ABC” has a Replay recorded from 1-2pm. Two hours later, an event was sent from your warehouse with a timestamp of 1:35pm with Distinct ID “ABC”. Server-side Stitching will infer that the event should belong in the same Replay.

To ensure Server-Side Stitching works, call [`identify()`](/docs/tracking-methods/sdks/swift#identify) from the client-side using our SDK with the user's `$user_id`. This guarantees that events generated from both the client-side and server-side share the same Distinct ID. Learn more about [identifying users](/docs/tracking-methods/id-management).

## Debugging

<Callout type="info">
`$mp_session_record` is exempt from your plan data allowance.
</Callout>

When a Replay capture begins, a "Session Recording Checkpoint" event will appear in your project, tracked as `$mp_session_record`. You may use this event to verify whether you have implemented Session Replay correctly.

If you are using the [recommended sampling method](/docs/session-replay/implement-session-replay/session-replay-ios#sampling) to capture your Replays but having trouble finding the Replays in your project, try calling `.startRecording()` manually and see if the `$mp_session_record` event appears. If it does appear but you are still struggling to locate your Replays, you may want to increase your sampling rate.

You can also check the Home page for your project to check for any recent Replays listed in the "Latest Replays" card.

If you are still struggling to implement, [submit a request to our Support team](https://mixpanel.com/get-support) for more assistance.

### Logging

Developers can enable or disable logging with the `loggingEnabled` property of the `MPSessionReplay` object.

**Example Usage**

```swift Swift
let token = Mixpanel.mainInstance().apiToken
let distinctId = Mixpanel.mainInstance().distinctId
let config = MPSessionReplayConfig(wifiOnly: false, recordSessionsPercent: 50.0)
let sessionReplayInstance = MPSessionReplay.initialize(token: token, distinctId: distinctId, config: config)
sessionReplayInstance.loggingEnabled = true // enable debug log
```

## Privacy

Mixpanel offers a privacy-first approach to Session Replay, including features such as data masking. Mixpanel's Session Replay privacy controls were designed to assist customers in protecting end user privacy. Read more [here](/docs/session-replay/session-replay-privacy-controls).

### User Data

The Mixpanel SDK will always mask all inputs. By default, all text, images, and WebViews on a page. 

You can unmask these element at your own discretion using the [`autoMaskedViews` config option described above](/docs/session-replay/implement-session-replay/session-replay-ios#additional-configuration-options).

#### Mark Views as Sensitive

If your app is SwiftUI-based or UIKit-based, all `UITextField` and `UILabel` components are masked by default. `UITextField` cannot be unmasked, while `UILabels` can be unmasked

You can also mark any views as sensitive using `mpReplaySensitive`. Views marked as "sensitive" will be masked.

**Example Usage**

```swift Swift
// Mark any view as sensitive

// SwiftUI
Image("family photo")
	.mpReplaySensitive(true)
 
// UIKit
let ccView = CreditCardUIView()
ccView.mpReplaySensitive = true
```

Set `mpReplaySensitive` to `false` to mark any view as safe. Views marked as "safe" will not be masked.

**Example Usage**

```swift Swift
// Mark any view as safe

// SwiftUI
BackgroundImage()
    .mpReplaySensitive(false)
 
//UIKit
let bgImage = BackgroundImage()
bgImage.mpReplaySensitive = false
```

### Retention

User replays are stored for 30 days after the time of ingestion. There is no way to view a replay older than 30 days old.

### Legal (Beta Terms)

Our Session Replay Beta Service Addendum can be found [here](https://mixpanel.com/legal/session-replay-beta-service-addendum/).

The alpha and beta of Mixpanel's mobile session replay SDK will track certain events and send them to Mixpanel so that Mixpanel can understand and improve the alpha and beta mobile session replay feature experience. These events include starting and stopping a session, adding and removing sensitive classes, adding sensitive views and adding safe views. Nothing about your application will be included in this tracking; only your usage of the Mixpanel Session Replay SDK.

## FAQ

#### How does Session Replay work in iOS?

Session Replay observes user interactions within your app, capturing UI hierarchy changes and storing them as images, which are then sent to Mixpanel. Mixpanel reconstructs these images, applying recorded events as an end-user completes them. 

Within Mixpanel's platform, you can view a reconstruction of your end-user's screen as they navigate your app. 

However, Session Replay is not a literal video recording of your end-user's screen; end-user actions are not video-recorded.

#### Can I prevent Session Replay from recording sensitive content?

The Mixpanel SDK will always mask all inputs. By default, all text, images, and WebViews on a page.

Additionally, you can customize how you leverage our SDK to fully control (1) where to record and (2) whom to record. Consider the [manual capture example scenarios](/docs/session-replay/implement-session-replay/session-replay-ios#manual-capture), [SDK configuration options](/docs/session-replay/implement-session-replay/session-replay-ios#additional-configuration-options), and [manual view masking example](/docs/session-replay/implement-session-replay/session-replay-ios#mark-views-as-sensitive) provided above to customize the replay capture of your implementation.

#### How can I estimate how many Replays I will generate?

If you already use Mixpanel, the [Session Start events](/docs/features/sessions) are a way to estimate the rough amount of replays you might expect. This is especially true if you use timeout-based query sessions. However, because our sessions are defined at query time, we cannot guarantee these metrics will be directly correlated.

When you enable Session Replay, use the above proxy metric to determine a starting sampling percentage, which will determine how many replays will be sent. You can always adjust this as you go to calibrate to the right level.

#### How does Session Replay affect my apps performance?

There is no impact on your app's performance when there are no user interactions or nothing changes on the screen. When there are user interactions, expect approximately 1% to 3% more CPU usage and around 1MB more memory consumption. There is no impact on disk I/O because Session Replay does not write anything to your disk. 

In our own testing, the overhead is unnoticeable, however this testing was not exhaustive and you may discover the recording overhead may negatively impact your mobile application performance depending on your application specifications. 

If you experience any performance degradations after installing Session Replay, please [reach out to our Support team](https://mixpanel.com/get-support).

#### What is the impact on bandwidth consumption?

The bandwidth impact of Session Replay depends on the setting of the [`wifiOnly` parameter](/docs/session-replay/implement-session-replay/session-replay-ios#additional-configuration-options).

By default, `wifiOnly` is set to `true`, which means replay events are only flushed to the server when the device has a wifi connection. If there is no wifi, flushes are skipped, and the events remain in the in-memory queue until WiFi is restored. This ensures no additional cellular data is used, preventing users from incurring additional data charges.

When `wifiOnly` is set to `false`, replay events are flushed with any available network connection, including cellular. In this case, the amount of cellular data consumed depends on the intensity of user interactions and the typical session length of your app. Users may incur additional data charges if large amounts of data are transmitted over cellular connections.

#### How does Session Replay for mobile work if my app is offline?

Session Replay for mobile does not work in offline mode.

#### Does it work in SwiftUI/UIKit apps?

[Yes.](/docs/session-replay/implement-session-replay/session-replay-ios#initialize)

#### Does it support Obj-C based app?

Yes, Objective-C and Swift are fully interoperable.





-------------
## Overview

Mixpanel Session Replay is the fastest way to understand the whole picture about your customers and make better product decisions, by combining quantitative and qualitative user insights.

When digging into customer journeys in Mixpanel’s analytics, you can understand “**where** do customers drop-off?” And now, Mixpanel Session Replay enables you to quickly follow-up with, “**why** do customers drop off?”

## Availability

Currently, iOS Session Replay is in invite-only Beta access for customers on our Enterprise plan.

For any questions about Session Replay or iOS Beta access, please reach out to your Account Manager. Note: as our Beta program is early access, our functionality, including data masking features, may have bugs and cause crashes. Be sure to test thoroughly before enabling in production.

For more information on our Web replay functionality, read [here](/docs/session-replay/session-replay-web)

Before publishing an App with Session Replay enabled, make sure to test it thoroughly to ensure that no sensitive data is exposed. Customizing masking rules in particular should be reviewed carefully. Like all Mixpanel product features, Mixpanel's customers are responsible for their configuration of Session Replay and ensuring sensitive data is not exposed.

# Quick Start Guide

## Prerequisite

You are already a Mixpanel customer and have the latest version of the Mixpanel Swift SDK installed (minimum supported version is `v4.3.1`). If not, please follow this [doc](/docs/quickstart) to get started.

## Installation

Add the Session Replay SDK using Swift Package Manager directly in Xcode:

1. In Xcode, go to **File → Add Package Dependencies...**
2. Paste the GitHub URL: `https://github.com/mixpanel/mixpanel-ios-session-replay-package`
3. Follow the prompts to select the latest version and add the package to your project.

## Initialize

You should have the main Mixpanel SDK installed (minimum version `v4.3.1`), if not, please refer to [Prerequisite](/docs/tracking-methods/sdks/swift) Add the initialization code at the start of your app's lifecycle.

SwiftUI

```swift
import Mixpanel
import MixpanelSessionReplay

struct SessionReplayDemoApp: App {
    @State private var isActive = true
    @Environment(\\.scenePhase) private var scenePhase

    var body: some Scene {
        WindowGroup {
            ...
        }
        .onChange(of: scenePhase) {
            if scenePhase == .active {
                let config = MPSessionReplayConfig(wifiOnly: false, recordSessionsPercent: 100.0)
                let sessionReplayInstance = MPSessionReplay.initialize(token: Mixpanel.mainInstance().apiToken, distinctId: Mixpanel.mainInstance().distinctId, config: config)

                sessionReplayInstance.loggingEnabled = true
                sessionReplayInstance.startRecording()
            }
        }
}

```

UIKit

```swift
import Foundation
import UIKit

import Mixpanel
import MixpanelSessionReplay

class AppDelegate: UIResponder, UIApplicationDelegate {

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
        Mixpanel.initialize(token: token, trackAutomaticEvents: true)

        let config = MPSessionReplayConfig(
            wifiOnly: false,
            recordSessionsPercent: 100.0
        )
        let sesionReplayInstance = MPSessionReplay.initialize(
            token: Mixpanel.mainInstance().apiToken,
            distinctId: Mixpanel.mainInstance().distinctId,
            config: config
        )
        #if DEBUG
        Mixpanel.mainInstance().loggingEnabled = true
        MPSessionReplay.getInstance()?.loggingEnabled = true
				#endif
        return true
    }

    func applicationDidBecomeActive(_ application: UIApplication) {
        MPSessionReplay.getInstance()?.startRecording()
    }

}

```

## Configuration Options

### Session Replay Config

Upon initialization you can provide a SessionReplayConfig object to specify the configuration. Currently, there are only three config options:

`wifiOnly` - when set to `true` replay events will only be flushed to the server when the device has a WiFi connection, if there is no WiFi, flushes are skipped and the events remain in the in-memory queue until WiFi is restored (or until the queue reaches its limit and the oldest events are evicted to make room for newer events). When set to `false` replay events will be flushed with any network connection, including cellular. - Default: `true`

`recordSessionsPercent` - this is a value between 0.0 and 100.0 that controls the sampling rate for recording session replays, at 0.0 no sessions will be recorded, at 100.0 all sessions will be recorded. - Default: 0.0

`autoMaskedViews` - This is a `Set` of enum options for the types of views that should be masked by the SDK automatically. By default it includes all available options: `Image`, `Text` and `Web` .

- Config to auto mask Images only

```swift
MPSessionReplayConfig(recordSessionsPercent: 100.0, autoMaskedViews: [.Image])
```

- Config to completely disable auto masking

```swift
MPSessionReplayConfig(recordSessionsPercent: 100.0, autoMaskedViews: [])
```

- Config with default setting which is to auto mask image, text and WebViews

```swift
MPSessionReplayConfig(recordSessionsPercent: 100.0)
```

`autoCapture` - This an enum to selectively disable the runtime method replacement functionality (aka "swizzling) in the event that it conflicts with another SDK ([like New Relic](https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/#method))

- Config to auto capture on both view controller lifecycle methods and touch events (Default)

```swift
MPSessionReplayConfig(recordSessionsPerecent: 100.0, autoCapture: .enabled)
```

- Config to auto capture only on view controller lifecycle events -- use this if you want to keep the touch based functionality in the conflicting SDK, but not their view controller functionality.

```swift
MPSessionReplayConfig(recordSessionsPerecent: 100.0, autoCapture: .viewControllerLifecycle)
```

- Config to auto capture only on touch events -- use this if you want to keep the view controller lifecycle functionality in the conflicting SDK, but not their touch functionality.

```swift
MPSessionReplayConfig(recordSessionsPerecent: 100.0, autoCapture: .touch)
```

- Config to completely disable auto capture -- use this if you want to keep all functionality in the conflicting SDK

```swift
MPSessionReplayConfig(recordSessionsPerecent: 100.0, autoCapture: .disabled)
```

### Manual Screenshot Capture

If you have partially or completely disabled automatic screen capture via the `autoCapture` config setting you can manually capture screenshots by calling `captureScreenshot()`:

```swift
MPSessionReplay.getInstance()?.captureScreenshot()
```

Or if the manual capture was triggered by a touch event:

```swift
MPSessionReplay.getInstance()?.captureScreenshot(withTouchEvent: touchEvent)
```

NOTE: If you choose to disable auto capture and do manual screen capturing instead, it will be up to you to determine when, where and how you call the `captureScreenshot()` method in your application. The most naïve approach would be to call it on a `Timer`, for example:

```swift
let screenshotTimer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in
    MPSessionReplay.getInstance()?.captureScreenshot()
}
```

Keeping in mind that this is relatively inefficient and will result in capturing unnecessary/unchanged screenshots, it's also possible to miss important moments in between the timed screenshots. Taking screenshots on demand at critical moments will always be preferable.

### Logging

Developers can enable or disable logging with the `loggingEnabled` property of the `MPSessionReplay` object.

### Example

```swift
let token = Mixpanel.mainInstance().apiToken
let distinctId = Mixpanel.mainInstance().distinctId
let config = MPSessionReplayConfig(wifiOnly: false, recordSessionsPercent: 50.0)
let sessionReplayInstance = MPSessionReplay.initialize(token: token, distinctId: distinctId, config: config)
sessionReplayInstance.loggingEnabled = true

```

## Enable Session Replay

**Start Recording**
If you want to record the entire activity since the app’s launch, we recommend starting the recording at the beginning of your app’s lifecycle. If you want to record only for specific flows or features, start the recording at the entry point of the flow or feature.

The recording automatically stops when the app goes to the background. Therefore, if you want to continuously record the replays, you’ll need to restart the replay once the app becomes active.

```swift
MPSessionReplay.getInstance()?.startRecording()
```

**Stop Recording**

The SDK automatically stops recording when the app goes to the background. However, if you’re recording replays for specific flows or features, you need to manually call `stopRecording` at the end of each flow or feature.

```swift
MPSessionReplay.getInstance()?.stopRecording()
```

## Privacy Settings

By default, Mixpanel will always mask all input text fields to exclude more sensitive views with user inputs from recording. To protect end-user privacy, input text fields cannot be unmasked .

By default, Mixpanel will mask all text. You can unmask text like `UILabels` at your discretion.

By default, Mixpanel will mask all images. Images can be unmasked at your discretion.

By default, Mixpanel will mask all WebViews. WebViews can be unmasked at your discretion.

[See `autoMaskedViews` in config section above.](#session-replay-config)

To mark any view as sensitive:

```swift
// SwiftUI
Image("family photo")
	.mpReplaySensitive(true)

// UIKit
let ccView = CreditCardUIView()
ccView.mpReplaySensitive = true
```

To mark any view as safe:

```swift
// SwiftUI
BackgroundImage()
    .mpReplaySensitive(false)

//UIKit
let bgImage = BackgroundImage()
bgImage.mpReplaySensitive = false
```

## Using Session Replay

Please refer to [Using Session Replay](/docs/session-replay/session-replay-web#using-session-replay)

## Legal (Beta Terms)

Our Session Replay Beta Service Addendum can be found [here](https://mixpanel.com/legal/session-replay-beta-service-addendum/).

The alpha and beta of Mixpanel’s mobile session replay SDK will track certain events and send them to Mixpanel so that Mixpanel can understand and improve the alpha and beta mobile session replay feature experience. These events include starting and stopping a session, adding and removing sensitive classes, adding sensitive views and adding safe views. Nothing about your application will be included in this tracking; only your usage of the Mixpanel Session Replay SDK.

## FAQ

### How does Session Replay work in iOS?

Session Replay observes user interactions within your app, capturing UI hierarchy changes and storing them as images, which are then sent to Mixpanel. Mixpanel reconstructs these images, applying recorded events as an end-user completes them. Within Mixpanel’s platform, you can view a reconstruction of your end-user’s screen as they navigate your app. However, Session Replay is not a literal video recording of your end-user’s screen; end-user actions are not video-recorded.

### What is the expected impact on my app performance?

There is no impact on your app’s performance when there are no user interactions or nothing changes on the screen. When there are user interactions, expect approximately 1% to 3% more CPU usage and around 1MB more memory consumption. There is no impact on disk I/O because Session Replay does not write anything to your disk. In our own testing, the overhead is unnoticeable, however this testing was not exhaustive and you may discover the recording overhead may negatively impact your mobile application performance depending on your application specifications. If you experience any performance degradations after installing Session Replay, please reach out to us.

### What is the bandwidth impact and will it cause users to incur additional data charges?

The bandwidth impact of Session Replay depends on the setting of the `wifiOnly` parameter.

When `wifiOnly` is set to `true` (default setting), replay events are only flushed to the server when the device has a WiFi connection. If there is no WiFi, flushes are skipped, and the events remain in the in-memory queue until WiFi is restored. This ensures no additional cellular data is used, preventing users from incurring additional data charges.

When `wifiOnly` is set to `false`, replay events are flushed with any available network connection, including cellular. In this case, the amount of cellular data consumed depends on the intensity of user interactions and the typical session length of your app. Users may incur additional data charges if large amounts of data are transmitted over cellular connections.

### How does Session Replay for mobile work if my app is offline?

Session Replay for mobile currently doesn’t work in offline mode.

### Am I able to sample our session replay collection rate?

Yes, you can configure the percentage of total replays that our SDK will capture as below.

```swift
let config = MPSessionReplayConfig(wifiOnly: false, recordSessionsPercent: 50.0)
let sessionReplayInstance = MPSessionReplay.initialize(token: token, distinctId: distinctId, config: config)

```

This out-of-the-box sampling method is random sampling: your SDK will decide randomly whether the currently SDK instance load falls into the sample or not. We recommend starting at 1% and increasing from there. Please note: if you expect low traffic, you can increase the starting sampling percentage. It is a good idea to control this with your own API, so you can change it on the fly without redeploying your app. While you're testing, we recommend that you set it to 100 and this ensure every user session will be sent to Mixpanel. Once testing is done, we recommend lowering this value in production.

### Does it work in SwiftUI/UIKit apps?

Yes, please refer to this [section](#initialize)

### Does it support Obj-C based app?

Yes, Objective-C and Swift are fully interoperable.

### Can I prevent Session Replay from recording sensitive content?

If your app is SwiftUI-based or UIKit-based, all `UITextField` and `UILabel` components are masked by default. `UITextField` cannot be unmasked, while `UILabels can be unmasked` You can also mask any view manually by calling:

```swift
// SwiftUI
Image("family photo")
	.mpReplaySensitive(true)

// UIKit
let ccView = CreditCardUIView()
ccView.mpReplaySensitive = true
```
