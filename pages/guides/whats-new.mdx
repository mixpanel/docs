---
title: "What's New"
description: "Auto-updating highlights from Mixpanel Changelogs"
---

import { useEffect, useMemo, useRef, useState } from 'react'
import { getPagesUnderRoute } from 'nextra/context'

export const changelogPages = getPagesUnderRoute('/changelogs')

export default function WhatsNewPromo() {
  // Build items from local pages
  const items = useMemo(() => {
    const parseDate = (s = '') => {
      const m = s.match(/(\d{4}-\d{2}-\d{2})/)
      return m ? m[1] : ''
    }
    const humanize = (s = '') =>
      s.replace(/^\d{4}-\d{2}-\d{2}-/, '').replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase())

    return (changelogPages || [])
      .map((p) => {
        const fm = p.frontMatter || p.meta || {}
        const route = p.route || ''
        if (!/\/changelogs\/.+/.test(route)) return null
        const name = p.name || route.split('/').pop() || ''
        const date = fm.date || parseDate(name) || parseDate(route)
        return {
          url: route,
          title: fm.title || p.title || humanize(name),
          date,
          description: fm.description || '',
          thumbnail: fm.thumbnail || '',
          video: fm.video || '',
          category: (fm.category || fm.type || '').toString()
        }
      })
      .filter(Boolean)
      .sort((a, b) => new Date(b.date || '') - new Date(a.date || ''))
  }, [])

  const shipped30d = useMemo(() => {
    const cutoff = Date.now() - 30 * 24 * 60 * 60 * 1000
    return items.filter(i => !isNaN(new Date(i.date)) && new Date(i.date).getTime() >= cutoff).length
  }, [items])

  const isNew = (dateStr) => {
    const d = new Date(dateStr); if (isNaN(d)) return false
    const days = (Date.now() - d.getTime()) / (1000 * 60 * 60 * 24)
    return days <= 14
  }
  const fmtDate = (dateStr) => {
    const d = new Date(dateStr); if (isNaN(d)) return dateStr || ''
    return d.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' })
  }

  // Large promo tile
  const Tile = ({ item }) => (
    <a href={item.url} className="block h-full rounded-2xl overflow-hidden bg-white/5 backdrop-blur-sm border hover:shadow-lg transition">
      <div className="p-5">
        <div className="text-xs uppercase tracking-wide text-gray-500 flex items-center gap-2">
          {fmtDate(item.date)}
          {item.category && <span>â€¢ {item.category}</span>}
          {isNew(item.date) && <span className="ml-2 inline-block px-1.5 py-0.5 text-[10px] rounded bg-emerald-100 text-emerald-700">NEW</span>}
        </div>
        <h3 className="mt-2 text-xl font-semibold leading-snug line-clamp-2">{item.title}</h3>
        {item.description && <p className="mt-2 text-sm opacity-90 line-clamp-3">{item.description}</p>}

        <div className="relative mt-5 h-56 rounded-xl overflow-hidden bg-black/10">
          {item.thumbnail ? (
            <img src={item.thumbnail} alt="" loading="lazy" className="w-full h-full object-cover" />
          ) : (
            <div className="w-full h-full" style={{
              background: 'radial-gradient(120% 120% at 0% 100%, rgba(168,85,247,0.25), transparent 60%), radial-gradient(120% 120% at 100% 0%, rgba(59,130,246,0.25), transparent 60%)'
            }} />
          )}
          <div className="pointer-events-none absolute inset-0" style={{ boxShadow: 'inset 0 0 120px rgba(255,255,255,0.15)' }} />
        </div>

        <div className="mt-4">
          <span className="inline-flex items-center gap-1 text-sm font-medium underline">
            Read update <span aria-hidden>-></span>
          </span>
        </div>
      </div>
    </a>
  )

  // Carousel using whitespace-nowrap + inline-block (very robust)
  const Carousel = ({ items, tileWidth = 420, gap = 24 }) => {
    const ref = useRef(null)
    const [canScroll, setCanScroll] = useState(false)
    const [progress, setProgress] = useState(0)

    useEffect(() => {
      const el = ref.current
      if (!el) return
      const update = () => {
        const max = el.scrollWidth - el.clientWidth
        setCanScroll(max > 0)
        setProgress(max <= 0 ? 0 : el.scrollLeft / max)
      }
      update()
      el.addEventListener('scroll', update, { passive: true })
      window.addEventListener('resize', update)
      return () => {
        el.removeEventListener('scroll', update)
        window.removeEventListener('resize', update)
      }
    }, [items.length])

    const page = () => Math.max(tileWidth + gap, Math.floor((ref.current?.clientWidth || 0) * 0.9))
    const left = () => ref.current?.scrollBy({ left: -page(), behavior: 'smooth' })
    const right = () => ref.current?.scrollBy({ left: page(), behavior: 'smooth' })

    return (
      <div className="relative not-prose">
        {/* glow behind tiles */}
        <div className="absolute -inset-x-8 -top-8 -bottom-6 rounded-[40px] pointer-events-none" style={{
          background: 'radial-gradient(60% 80% at 10% 0%, rgba(168,85,247,0.25), transparent 70%), radial-gradient(60% 80% at 90% 100%, rgba(59,130,246,0.25), transparent 70%)',
          filter: 'blur(20px)'
        }} />

        {/* scroll container */}
        <div
          ref={ref}
          className="relative overflow-x-auto pb-10 whitespace-nowrap"
          style={{
            WebkitOverflowScrolling: 'touch',
            scrollbarWidth: 'none',
            msOverflowStyle: 'none',
            maskImage: 'linear-gradient(to right, transparent, black 32px, black calc(100% - 32px), transparent)',
            WebkitMaskImage: 'linear-gradient(to right, transparent, black 32px, black calc(100% - 32px), transparent)'
          }}
          aria-label="Latest updates"
        >
          {items.map((i, idx) => (
            <div
              key={i.url}
              className="align-top inline-block"
              style={{ width: tileWidth, marginRight: idx === items.length - 1 ? 0 : gap }}
            >
              <Tile item={i} />
            </div>
          ))}
        </div>

        {/* progress bar */}
        {canScroll && (
          <div className="absolute left-0 right-0 bottom-3 h-1 rounded-full bg-white/10 overflow-hidden">
            <div className="h-full bg-fuchsia-500" style={{ width: `${Math.round(progress * 100)}%` }} />
          </div>
        )}

        {/* arrows */}
        {canScroll && (
          <>
            <button
              onClick={left}
              aria-label="Previous"
              className="hidden md:flex absolute right-16 bottom-6 translate-y-1/2 rounded-full border bg-white/90 text-black px-3 py-2 shadow"
            >
              &lt;
            </button>
            <button
              onClick={right}
              aria-label="Next"
              className="hidden md:flex absolute right-4 bottom-6 translate-y-1/2 rounded-full border bg-white/90 text-black px-3 py-2 shadow"
            >
              &gt;
            </button>
          </>
        )}
      </div>
    )
  }

  // Layout: left intro + right carousel
  return (
    <section className="not-prose mx-auto max-w-7xl">
      <div className="grid grid-cols-1 lg:grid-cols-12 gap-10 items-start">
        <div className="lg:col-span-4">
          <h1 className="text-4xl font-bold tracking-tight">New releases</h1>
          <p className="mt-3 text-base opacity-80">
            Learn more about our newly released capabilities. We shipped <strong>{useMemo(() => {
              const cutoff = Date.now() - 30 * 24 * 60 * 60 * 1000
              return items.filter(i => !isNaN(new Date(i.date)) && new Date(i.date).getTime() >= cutoff).length
            }, [items])}</strong> updates in the last 30 days.
          </p>
        </div>

        <div className="lg:col-span-8">
          <Carousel items={items.slice(0, 16)} />
        </div>
      </div>

      <div className="mt-8 text-sm opacity-70">
        Do not see what you are looking for? See the full <a className="underline" href="/changelogs">Changelog</a>.
      </div>
    </section>
  )
}
